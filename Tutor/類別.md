## 抽象資料型別 (ADT)

ADT 是指一種由資料與操作構成的資料型別，它隱藏實作細節，只提供介面讓使用者操作。

類別 class 就是一種實作 ADT 的方式，結合了「資料成員」與「成員函式」。

## class 基本語法

### 建立 class

{% raw %}

```cpp
class Student {
private: // 表示這個資料只有類別裡的函數可以用
    int StuID;  // 學號(變數)
public: //  表示這個函數可以在類別外呼叫
    void input_data();  // 輸入資料(函數)
    void show_data();   // 顯示資料(函數)
};
```

{% endraw %}

### 利用 class 建立 object

{% raw %}

```cpp
Student stud1;  // 建立一個 Student 物件叫 stud1
```

{% endraw %}

### 使用 object

{% raw %}

````cpp
## 抽象資料型別 (ADT)

ADT 是指一種由資料與操作構成的資料型別，它隱藏實作細節，只提供介面讓使用者操作。

類別 class 就是一種實作 ADT 的方式，結合了「資料成員」與「成員函式」。

## class 基本語法

### 建立 class

{% raw %}

```cpp
class Student {
private: // 表示這個資料只有類別裡的函數可以用
    int StuID;  // 學號(變數)
public: //  表示這個函數可以在類別外呼叫
    void input_data();  // 輸入資料(函數)
    void show_data();   // 顯示資料(函數)
};
````

{% endraw %}

### 利用 class 建立 object

{% raw %}

```cpp
Student stud1;  // 建立一個 Student 物件叫 stud1
```

{% endraw %}

### 使用 object(使用作用域解析運算子)

{% raw %}

```cpp
#include <iostream>
using namespace std;


class Student {
private: // 表示這個資料只有類別裡的函數可以用
    int StuID;  // 學號(變數)
public: //  表示這個函數可以在類別外呼叫
    void input_data();  // 輸入資料(函數)
    void show_data(){ // 顯示資料(函數)
        cout << "學號是：" << StuID << endl;
    }
};


// 定義成員函數的內容 => ::叫做「作用域解析運算子」
void Student::input_data() {
    cout << "請輸入學號：";
    cin >> StuID;
}


// 使用
int main() {
    Student stud1;         // 宣告一個物件
    stud1.input_data();    // 呼叫輸入資料的函數
    stud1.show_data();     // 呼叫顯示資料的函數
    return 0;
}
```

{% endraw %}

## 建構子（Constructor）

建構子是「在你建立物件時自動執行的特殊函數」，用途是用來初始化物件裡的成員變數。

特點：

-   名字與 class 名稱一樣
-   不需要回傳型態
-   可以有多個建構子 => 支援「多載」（overloading）
-   沒有寫建構子，系統會自動幫你生一個「預設建構子」

### 範例：建立沒有參數的 Constructor

{% raw %}

```cpp
#include <iostream>
using namespace std;

class Student {
private:
    int StuID;
    float English, Math, Total, Average;
public:
    Student();  // 預設建構子（沒參數）
    Student(int id, float E, float M); // 自訂建構子（有三個參數）
    void show_data(); // 顯示資料
};

// 作用域解析運算子中去給member值
Student::Student() {
    StuID = 920101;
    English = 60;
    Math = 80;
}

void Student::show_data() {
    cout << Math << "\n";
}

int main() {
    Student stud1; // 建立object的時候，會自動去跑object的construct
    stud1.show_data();
    return 0;
}
```

{% endraw %}

### 範例：建立有參數的 Constructor

{% raw %}

```cpp
#include <iostream>
using namespace std;

class Student {
private:
    int StuID;
    float English, Math, Total, Average;
public:
    Student();  // 預設建構子（沒參數）
    Student(int id, float E, float M); // 自訂建構子（有三個參數）
    void show_data(); // 顯示資料
};


Student::Student(int id, float E, float M) {
    StuID = id;
    English = E;
    Math = M;
}

void Student::show_data() {
    Total = English + Math;
    Average = Total / 2;
    cout << "學號是: " << StuID << endl;
    cout << "總分是: " << Total << "，平均是: " << Average << endl;
}

int main() {
    Student stud2(920102, 30, 40); // 呼叫三參數建構子
    stud2.show_data();          // 顯示 stud2 的資料
}
```

{% endraw %}

## 解構子（Destructor）

解構子是一種特殊函數，當一個物件「生命週期結束」時，會自動執行來釋放資源或做收尾工作。

功能：

-   自動執行「清理工作」 => 程式結束、物件離開作用域、delete 物件時就會被呼叫。
-   幫你釋放記憶體或結束前的動作（像是關檔案、釋放陣列等）。

語法：

{% raw %}

```cpp
~類別名稱(); // 注意前面有一個 ~ 符號，不能有任何參數，也不寫回傳型態
```

{% endraw %}

### 範例：使用 Destructor

{% raw %}

```cpp
#include <iostream>
using namespace std;

class testN {
private:
    int no[10];     // 陣列
    int i;
public:
    testN();        // 建構子
    ~testN();       // 解構子
};


// 定義constructor
testN::testN() {
    int i;
    for(i = 0; i < 10; i++) {
        no[i] = i;
    }
    cout << "建構子執行完成。" << endl;
}


// 定義Destructor
testN::~testN() {
    cout << "解構子發動中。\n陣列內的內容：";
    for(i = 0; i < 10; i++) {
        cout << no[i] << " ";
    }
    cout << "\n物件已執行完畢。" << endl;
}

// 使用解構子的函式
void show_result() {
    testN test1;  // 宣告物件（建構子會在這裡執行）
    return;       // 函數結束時 test1 的解構子會自動執行
}

int main() {
    show_result();  // 呼叫函式，裡面會建立 test1
    return 0;
}

```

{% endraw %}

## 指標物件

上述的物件建立方式屬於「靜態建立物件」=> 當程式跑到這行時，stud1 就會自動建立，也會自動釋放記憶體。

如果希望「動態建立物件」就要用「指標物件」的方式

{% raw %}

```cpp
Student* stud1 = new Student;
```

{% endraw %}

這時會：

-   在記憶體堆區（heap）分配空間。
-   回傳該物件的指標（Student\*）。
-   你必須手動用 delete 去刪除物件。

### 範例：使用指標物件動態建立

{% raw %}

```cpp
#include <iostream>
using namespace std;

class Student {
private:
    char StuID[8];         // 學號（用字元陣列表示）
    float Score_E, Score_M, Score_T, Score_A;  // 分數資料
public:
    // 建構子：物件建立時自動執行
    Student() {
        cout << "*** 執行建構子 $$$ ***" << endl;
    }
    // 解構子：物件刪除時自動執行
    ~Student() {
        cout << "### 執行解構子 ###" << endl;
    }
    // 函數
    void input_data() {
        cout << "請輸入學號及科系標籤：" << endl;
        cout << "學號：";
        cin >> StuID;
        cout << "請輸入英文成績：";
        cin >> Score_E;
        cout << "請輸入數學成績：";
        cin >> Score_M;
    }
    void show_data(); // 這邊我用作用域解析運算子去做
};

void Student::show_data(){
    Score_T = Score_E + Score_M;
    Score_A = Score_T / 2;
    cout << "==============================" << endl;
    cout << "學號是：" << StuID << endl;
    cout << "總分是 " << Score_T << " 分，平均是 " << Score_A << " 分" << endl;
    cout << "==============================" << endl;
}

int main() {
    Student* stud1 = new Student; // 使用 new 建立指標物件（在 heap 動態記憶體中建立）

    // 使用指標呼叫成員函數（用 ->）
    stud1->input_data();
    stud1->show_data();

    delete stud1; // 使用 delete 釋放指標物件（呼叫解構子）
    return 0;
}
```

{% endraw %}

## 物件陣列

陣列可以放 int、放 char、放 string，也可以放 object

{% raw %}

```cpp
#include <iostream>
using namespace std;

class Baseball {
private:
    char player[20];
    int fires;
    int safes;

public:
    void inputplayer();   // 輸入資料
    void showplayer();    // 顯示資料
    float countsafe();    // 計算打擊率 = safes / fires
};

void Baseball::inputplayer() {
    cout << "請輸入球員名字：";
    cin >> player;
    cout << "請輸入打數：";
    cin >> fires;
    cout << "請輸入安打數：";
    cin >> safes;
}

void Baseball::showplayer() {
    cout << "球員：" << player << endl;
    cout << "打數：" << fires << "，安打數：" << safes << endl;
    cout << "打擊率：" << countsafe() << endl;
}

float Baseball::countsafe() {
    if (fires == 0) return 0.0;
    return (float) safes/fires;
}

int main(){
    Baseball b[3];        // 宣告陣列（3 位球員）
    for(int i=0; i<3; i++){
        b[i].inputplayer();  // 輸入每個球員資料
    }
    for(int i=0; i<3; i++){
        b[i].showplayer();   // 顯示球員資訊與打擊率
    }
    return 0;
}
```

{% endraw %}

## 朋友函數(friend)

C++ 類別通常會把成員設為 private，不能讓別人直接存取。但你可以指定某些「朋友（friend）」函數或類別來特別允許他們存取 private 成員！

### 範例：未使用 friend 而失敗

-   假設要宣告一個 class【Student】，裡面儲存期末總分(Score_T)
-   然後要寫一個外部變數(add_bonus)，作用是幫忙加分

{% raw %}

```cpp
#include <iostream>
using namespace std;

class Student {
private:
    int Score_T;  // 期末總分

public:
    Student(int s) {
        Score_T = s;
    }
};

// 外部函數，想要幫忙加分
int add_bonus(Student s) {
    return s.Score_T + 10;  // ❌ 錯誤：Score_T 是 private，外面看不到
}

int main() {
    Student s1(70);
    cout << "加分後的成績是：" << add_bonus(s1) << endl;
    return 0;
}

// .\test.cpp:16:14: 錯誤：「int Student::Score_T」 is private within this context

// Score_T 是 private，外部函數 add_bonus() 不是 Student 的成員 => 所以不能直接「偷看」成績 => 封裝
```

{% endraw %}

### 範例：使用 friend function 修正

{% raw %}

```cpp
#include <iostream>
using namespace std;

class Student {
private:
    int Score_T;  // 期末總分

public:
    Student(int s) {
        Score_T = s;
    }
    friend int add_bonus(Student);  // ✅ 宣告這個外部函數是朋友！
};

// 外部函數，想要幫忙加分
int add_bonus(Student s) {
    return s.Score_T + 10;  // ❌ 錯誤：Score_T 是 private，外面看不到
}

int main() {
    Student s1(70);
    cout << "加分後的成績是：" << add_bonus(s1) << endl;
    return 0;
}
```

{% endraw %}

## 朋友類別(friend class)

friend 類別是一種權限授予機制，讓另一個類別可以存取本類別的 private 和 protected 成員。

### 範例：未使用 friend class 而失敗

-   假設要宣告一個 class【Student】，裡面儲存期末總分(Score_T)
-   另一格 class【Teacher】負責批改與顯示成績，但它不是 Student 的成員類別

{% raw %}

```cpp
#include <iostream>
using namespace std;

class Student {
private:
    int Score_T;
public:
    Student(int s) {
        Score_T = s;
    }
};

class Teacher {
public:
    void show_score(Student s) {
        cout << "學生分數是：" << s.Score_T << endl;  // ❌ 錯誤！Score_T 是 private
    }
};

int main() {
    Student s1(80);
    Teacher t;
    t.show_score(s1);
    return 0;
}

// .\test.cpp: 在 「void Teacher::show_score(Student)」 成員函式中:
// .\test.cpp:16:37: 錯誤：「int Student::Score_T」 is private within this contex
```

{% endraw %}

### 範例：使用 friend class 修正

{% raw %}

```cpp
#include <iostream>
using namespace std;

class Student {
private:
    int Score_T;
public:
    Student(int s) {
        Score_T = s;
    }
    friend class Teacher;  // ✅ 宣告整個 Teacher 類別是朋友
};

class Teacher {
public:
    void show_score(Student s) {
        cout << "學生分數是：" << s.Score_T << endl;  // ❌ 錯誤！Score_T 是 private
    }
};

int main() {
    Student s1(80);
    Teacher t;
    t.show_score(s1);
    return 0;
}
```

{% endraw %}

## protected(繼承的部分再說)

protected 是介於 private 和 public 之間的存取控制修飾詞

| 權限修飾詞  | 自己類別內可存取 | 子類別可存取 | 外部可存取 |
| ----------- | ---------------- | ------------ | ---------- |
| `private`   | ✅               | ❌           | ❌         |
| `protected` | ✅               | ✅           | ❌         |
| `public`    | ✅               | ✅           | ✅         |

## 1. for 迴圈

### 1.1. 範例：質數判斷

{% raw %}

```cpp
#include <iostream>
using namespace std;

main(){
    int n;
    cin >> n;
    bool prime = true;
    for (int i = 2; (i * i) <= n; i++)
        if ((n % i) == 0){
            prime = false;
            break;
        }
    cout << prime << endl;
}
```

{% endraw %}

## 2. while 迴圈

## 3. break

## 4. continue

## 5. Zero Judge

### 5.1. a059. 完全平方和

給你一個範圍 a 到 b ，請你找出 a 與 b 之間所有完全平方數的和。

e.g. 範圍 3-25，表示 3 至 25 中所有完全平方數的和就是 4 + 9 + 16 + 25 = 54 。

{% raw %}

```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    int T;
    cin >> T;

    for (int caseNum = 1; caseNum <= T; ++caseNum) {
        int a, b, sum = 0;
        cin >> a >> b;

        ///// 從 sqrt(a) 到 sqrt(b) 中的整數，檢查平方數 /////
        int start = ceil(sqrt(a));
        int end = floor(sqrt(b));
        for (int i = start; i <= end; ++i) {
            sum += i * i;
        }
        cout << "Case " << caseNum << ": " << sum << endl;
    }
    return 0;
}
```

{% endraw %}

### 5.2. a104. 排序

{% raw %}

```cpp
/**
 * 解法01：用bubble sort去解
 * Bubble Sort：重複走訪數列，每次比較相鄰兩個元素，如果順序錯了就交換，最大的值會被「冒」到後面，像泡泡往上浮。
 * 外圈：0到n-1 => 因為我們最多需要做 n-1 輪冒泡（最後一輪就不需要再比了）
 * 內圈：0到n-1-i =>
 *      每一輪會把目前剩下最大值移到尾端
 *      因此第 i 輪後，最後 i 個元素已經排好不用再比。所以這一輪最多只需要比較到 n - 1 - i 的位置
 */
#include <iostream>
using namespace std;

int main() {
    int n;
    while (cin >> n) {
        int arr[1000];

        for (int i = 0; i < n; ++i) {
            cin >> arr[i];
        }

        // 冒泡排序
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n - 1 - i; ++j) {
                if (arr[j] > arr[j + 1]) {
                    swap(arr[j], arr[j + 1]);
                }
            }
        }

        // 輸出結果
        for (int i = 0; i < n; ++i) {
            if (i > 0) cout << " ";
            cout << arr[i];
        }
        cout << "\n";
    }

    return 0;
}
```

{% endraw %}

{% raw %}

```cpp
/**
 * 解法02：用insert sort去解
 * 就像打撲克牌時整理手牌：每次將新牌插入前面已排序的牌堆中。
 * 時間複雜度為 ( O(n^2) )，但對小筆資料或幾乎有序的資料表現不錯。
 *
 * 假設你要排序的陣列是 arr = [7, 4, 5, 2]
 * 第一回合：i = 1，key = 4
 *      比較 arr[0] = 7 和 key = 4，因為 7 > 4 → 把 7 往右移
 *      插入 4 → arr = [4, 7, 5, 2]
 * 第二回合：i = 2，key = 5
 *      比較 7 > 5 → 移動
 *      比較 4 < 5 → 停止
 *      插入 5 → arr = [4, 5, 7, 2]
 * 第三回合：i = 3，key = 2
 *      7 > 2 → 移動
 *      5 > 2 → 移動
 *      4 > 2 → 移動
 *      插入 2 → arr = [2, 4, 5, 7]
 */
#include <iostream>
using namespace std;

int main() {
    int n;
    while (cin >> n) {
        int arr[1001];

        // 讀入資料
        for (int i = 0; i < n; ++i) {
            cin >> arr[i];
        }

        // 插入排序
        for (int i = 1; i < n; ++i) {
            int key = arr[i]; // 將目前這個元素「暫存」起來
            int j = i - 1; // 從已排序區的最後一個元素開始往左比
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j]; // 如果前一個元素比較大，就往右移
                j--;
            }
            arr[j + 1] = key; // 將 key 放入正確位置（空出來的位置）
        }

        // 輸出結果
        for (int i = 0; i < n; ++i) {
            if (i > 0) cout << " ";
            cout << arr[i];
        }
        cout << "\n";
    }
    return 0;
}
```

{% endraw %}

{% raw %}

```cpp
// 解法03：用merge sort去解

```

{% endraw %}

{% raw %}

```cpp
// 解法04：用quick sort去解

```

{% endraw %}

### 5.3. a121. 質數又來囉

針對每組輸入的區間 [a, b]（保證 b−a ≤ 1000）計算範圍內的質數個數。

{% raw %}

```cpp
#include <iostream>
#include <cmath>
using namespace std;

// 判斷一個數是否為質數
bool isPrime(int n) {
    if (n < 2) return false;
    if (n == 2) return true;
    if (n % 2 == 0) return false;
    for (int i = 3; i < sqrt(n)+1; i += 2) {
        if (n % i == 0) return false;
    }
    return true;
}

int main() {
    int a, b;
    while (cin >> a >> b) {
        int count = 0;
        for (int i = a; i <= b; ++i) {
            if (isPrime(i)) count++;
        }
        cout << count << endl;
    }
    return 0;
}
```

{% endraw %}

## 6. HW：

-   a058. MOD3
-   a065. 提款卡密碼
-   a147. Print it all
-   a148. You Cannot Pass?!
-   a149. 乘乘樂

## 1. 陣列的基本觀念

在需要同時儲存多個同型態變數的情境下，可以使用陣列一次宣告多個變數，減少重複撰寫。

### 1.1. 範例：固定大小的一維陣列宣告

{% raw %}

```cpp
#define ARRAYSIZE 10 // macro
int a[ARRAYSIZE];

```

{% endraw %}

## 2. 一維陣列

{% raw %}

```cpp
#include <iostream>
using namespace std;

int main() {
    int arr[5] = {1,2,3,4,5}; // 寫法01
    int arr[] = {1,2,3,4,5}; // 寫法02
    int arr[100] = {0}; // 寫法02 長度100，裡面都是0
}
```

{% endraw %}

## 3. 在迴圈中使用陣列

### 3.1. 範例：印出陣列中的值

{% raw %}

```cpp
// 寫法01
#include <iostream>
using namespace std;
#define ARRAYSIZE 10

main(){
    // int a[ARRAYSIZE];
    // for (int i = 0; i < ARRAYSIZE; i++)
    //     cin >> a[i];
    int a[ARRAYSIZE] = {3, 6, 1, 8, 4, 9, 10, 4, 7, 6};
    int sum {0};
    for (int i = 0; i < ARRAYSIZE; i++)
        sum += a[i];
    cout << sum << endl;
}
```

{% endraw %}

{% raw %}

```cpp
// 寫法02
#include <iostream>
using namespace std;
#define ARRAYSIZE 10

main(){
    // int a[ARRAYSIZE];
    // for (int i = 0; i < ARRAYSIZE; i++)
    //     cin >> a[i];
    int a[ARRAYSIZE] = {3, 6, 1, 8, 4, 9, 10, 4, 7, 6};
    int sum = 0;
    for (int i: a)
        sum += i;
    cout << sum << endl;
}
```

{% endraw %}

## 4. assert

是用來「偵錯用的斷言檢查工具」，可幫助程式確認某條件在執行時是否成立。

語法格式

{% raw %}

```cpp
#include <cassert> // 必須引入 <cassert> 標頭檔。

assert(condition); // 當 condition為 false，會顯示錯誤訊息並終止程式
```

{% endraw %}

### 4.1. 範例：只能輸入比 5 小的數，否則抱錯

{% raw %}

```cpp
#include <iostream>
#include <cassert>
using namespace std;

int main() {
    int j = 0;
    while (cin >> j) {
        assert(j >= 0 && j < 5);  // 檢查 j 合法範圍
        cout << "OK" << endl;
    }
}

```

{% endraw %}

### 4.2. 範例：一維陣列中尋找特定值

{% raw %}

```cpp
#include <iostream>
using namespace std;
#define ARRAYSIZE 6

main(){
    int keys[] {3, 4, 6, 2, 8, 10};
    int key;
    while (cin >> key) {
            bool found = false;
            for (int i = 0; i < ARRAYSIZE && !found; i++)
                if (key == keys[i]) {
                    cout << i << endl;
                    found = true;
                    }
            if (!found)
            cout << "-1" << endl;
    }
}
```

{% endraw %}

### 4.3. 範例：質數判定

{% raw %}

```cpp
#include <iostream>
#include <cassert>
using namespace std;

int main() {
    int n;
    cin >> n;  // 目標：列出前 n 個質數，例如 20

    int count = 0;
    int number = 2;

    while (count < n) {
        bool isPrime = true;
        for (int i = 2; i * i <= number; ++i) {
            if (number % i == 0) {
                isPrime = false;
                break;
            }
        }
        if (isPrime) {
            cout << number << " ";
            count++;
        }
        number++;
    }
    cout << endl;
    return 0;
}

```

{% endraw %}

### 4.4. 範例：泡沫排序法

{% raw %}

```cpp
#include <iostream>
#include <cassert>
using namespace std;

int main() {
    int n[] = {5, 4, 3, 2, 1};  // 初始陣列
    int m = sizeof(n) / sizeof(n[0]);  // 陣列長度

    // Bubble Sort 排序
    for (int i = 0; i < m - 1; i++) {
        for (int j = 0; j < m - 1 - i; j++) {
            if (n[j] > n[j + 1]) {
                swap(n[j], n[j + 1]);
            }
        }
    }

    // 輸出排序後的結果
    for (int i = 0; i < m; i++)
        cout << n[i] << ' ';
    cout << endl;
    return 0;
}
```

{% endraw %}

### 4.5. 範例：一維記憶體配置與位址

-   使用 `&變數` 可以取得該變數在記憶體中的位址。
-   若要以十六進位顯示，C++ 預設就是印出十六進位。

{% raw %}

```cpp
cout << &a[i] << endl;
```

{% endraw %}

{% raw %}

```cpp
#include <iostream>
using namespace std;

int main() {
    int arr[] = {5, 4, 3, 2, 1};  // 初始陣列
    for(int i=0;i<5;i++){
        cout << &(arr[i]) << endl;
    }
    return 0;
}

// 0x7ffffcc00
// 0x7ffffcc04
// 0x7ffffcc08
// 0x7ffffcc0c
// 0x7ffffcc10
```

{% endraw %}

## 5. 多維陣列（矩陣）

{% raw %}

```cpp
// 初始化方式
int array[2][3] = { {1, 2, 3}, {4, 5, 6} }; // 方式01
int array[2][3] = { 1, 2, 3, 4, 5, 6 }; // 方式02
```

{% endraw %}

## 6. 二維陣列的記憶體配置

{% raw %}

```cpp
#include <iostream>
using namespace std;

int main() {
    int a[3][4] = {
        {1,  2,  3,  4},
        {5,  6,  7,  8},
        {9, 10, 11, 12}
    };

    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
            cout << &a[i][j] << "\t";
        }
        cout << endl;
    }
    return 0;
}

```

{% endraw %}

## 7. Zero Judge

### 7.1. a015. 矩陣的翻轉

{% raw %}

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int m, n;
    while(cin >> m >> n){
        vector<vector<int>> num(m, vector<int>(n));

        // 讀入矩陣
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                cin >> num[i][j];
            }
        }

        // 建立轉置矩陣
        vector<vector<int>> ans(n, vector<int>(m));
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                ans[j][i] = num[i][j];
            }
        }

        // 輸出轉置後矩陣
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                cout << ans[i][j] << " ";
            }
            cout << endl;
        }
    }
    return 0;
}
```

{% endraw %}

### 7.2. a215. 明明愛數數

給兩個數字，n 跟 m。試問 n、n+1、n+2 、...，相加到多少會超過 m

{% raw %}

```cpp
#include <iostream>
using namespace std;

int main() {
    int n, m;
    while (cin >> n >> m) {
        int sum = 0;
        int count = 0;
        while(true){
            count++;
            sum += n;
            n++;
            if(sum>m) break;
        }
        cout << count << endl;
    }
    return 0;
}
```

{% endraw %}
